##Типы векторов (все векторы являются атомарными типами)

#Приведение типов векторов: logical -> integer -> double -> character. Например:
#c(False, 1.5) - тип double/numeric, c(False, 1.5, "abs) - тип character(все числа становятся строками)
#Функция as.*(type) - принудительное приведение к какому-либо вектора. Например as.numeric(b) 

##Типы векторов, и синтаксис их создания: тип(вектор)
#Atomic(атомарные) - вектор, все элементы которого одного типа
#logical(TRUE/FALSE) - логический вектор
#integer - целочисленный вектор
#numeric/double - вектор чисел с плавающей точкой
#complex - вектор комплексных чисел
#character - вектор со строковыми данными 
#raw - байтовые последовательности

##Работа с векторами

#Функция sample(1:100, n, replace = T)возвращает n случайных чисел из промежутка в 1 аргументе, replace - повторы
#Функция floor(x) - округляет число вниз
#Функция length(x) - возвращает длину вектора, можно урезать вектор length(x) <- 4(1-е 4 элемента вектора)
#функция names(x) - возвращает имена элементов вектора, names(x) <- x1 изменяет имена
#функция с() - "combine" для создания вектора
#функция seq(x, y, step, length, by) -(sequence) создает последовательность от x до y с шагом или длиной
#функция rep(x, times, each, length)-(repeat)повторяет вектор несколько раз, или каждый его 
#элемент несколько раз, или до достижения длины
#функция sort(x)  - упорядочивает вектор
#Функция uniq(x) - оставляет только уникальные элементы в векторе. Пример:
#Функция all(x < 100) - возвращает TRUE FALSE
#Функция any(x < 100) - возвращает TRUE FALSE
#Функция which(x >=50) - возвращает индексы элементов
#Функция which.min(x >=50) - возвращает минимальный индекс элемента по условию в скобках
#Функция which.max(x >=50) - возвращает максимальный индекс элемента по суловию
#Функция attr(x, "atribute")-добавляет атрибут вектору,удаление атрибута atributes(x) <- NULL 

##Правило переписывания векторов
z <- c(1:3)+c(1:5) #можно производить действия с векторами разной длины! 
#операция будет зациклена

a <- seq(0, 1, 1/3)
b <- seq(0, 1, 1/7)
c <- c(a, b)
unique(sort(c)) #сортируем и оставляем только уникальные элементы

#Задача по преобразованию вектора
get_fractions <- function(m, n){ 
  unique(
    sort(
      c(
        c(0:m)/m, 
        c(0:n)/n),
      decreasing =TRUE
      )
    )
}

#Задача - проверка вектора на монотонность

is_monotone <- function(x) {
  all(x[-1]-x[-length(x)]<=0) | all(x[-1]-x[-length(x)]>=0)
}

get_fractions(3, 7)

#задача комбинаторика

combin_count <- function(n, k, with_repetitions = FALSE) {
  ifelse(with_repetitions == FALSE, 
         factorial(n)/(factorial(k)*factorial(n-k)),
         factorial(n+k-1)/(factorial(k)*factorial(n-1)))
}

##Доступ к списку хоткеев в R осуществляется по клавишам alt+shift+k

##функция all.equal(x, y) - для точного сравнения чисел x и y


